{
    "version": "https://jsonfeed.org/version/1",
    "title": "人生几何 • All posts by \"nlp\" category",
    "description": "",
    "home_page_url": "https://RenshengJi.github.io",
    "items": [
        {
            "id": "https://renshengji.github.io/2023/07/09/%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%91%A8%E6%8A%A5%E7%9A%84%E5%89%AF%E6%9C%AC/",
            "url": "https://renshengji.github.io/2023/07/09/%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%91%A8%E6%8A%A5%E7%9A%84%E5%89%AF%E6%9C%AC/",
            "title": "人生几何的科研之旅——第二周周报",
            "date_published": "2023-07-09T15:48:03.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>[TOC]</p>\n<h3 id=\"多模态小样本图像识别\"><a href=\"#多模态小样本图像识别\" class=\"headerlink\" title=\"多模态小样本图像识别\"></a>多模态小样本图像识别</h3><h4 id=\"Adaptive-Cross-Modal-Few-shot-Learning\"><a href=\"#Adaptive-Cross-Modal-Few-shot-Learning\" class=\"headerlink\" title=\"Adaptive Cross-Modal Few-shot Learning\"></a>Adaptive Cross-Modal Few-shot Learning</h4><h5 id=\"算法动机：\"><a href=\"#算法动机：\" class=\"headerlink\" title=\"算法动机：\"></a>算法动机：</h5><ul>\n<li><p>在图像分类任务上，几乎任何单一模态都有其失效的情况，下面这个图非常直观的说明了这点。这是使用多模态进行图像分类的根本原因。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"../images/4.png\"\n                      alt=\"IMG_3941\" style=\"zoom:50%;\" \n                >\n</li>\n<li><p>在小样本的情况下，来源于视觉模态的信息是有限的，而semantic语义模态的信息（来自于无监督大规模语料库）可以提供丰富的先验知识和上下文！这是在小样本图像识别任务中引入多模态，特别是语义模态的原因。</p>\n</li>\n</ul>\n<h5 id=\"算法原理：\"><a href=\"#算法原理：\" class=\"headerlink\" title=\"算法原理：\"></a>算法原理：</h5><ul>\n<li><p>总的来说，本文提出的算法其实就是在基于度量的prototypical原型学习基础之上，将原来只包含视觉模态信息的类原型，加权引入了语义模态的信息。如下图所示：</p>\n</li>\n<li><p>其中，$g$将来自语义模态的信息转换到和$p_c$相同的维度</p>\n</li>\n<li><p>其中，h用来计算加权参数，不同的类别，得到的加权参数是不一样的，这可以让模型根据不同类别的特征，选择更好描述该类的模态</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"../images/5.png\"\n                      alt=\"截屏2023-07-09 15.23.23\" style=\"zoom:50%;\" \n                ></li>\n</ul>\n<h4 id=\"Learning-Compositional-Representations-for-Few-Shot-Recognition\"><a href=\"#Learning-Compositional-Representations-for-Few-Shot-Recognition\" class=\"headerlink\" title=\"Learning Compositional Representations for Few-Shot Recognition\"></a>Learning Compositional Representations for Few-Shot Recognition</h4><h5 id=\"算法动机：-1\"><a href=\"#算法动机：-1\" class=\"headerlink\" title=\"算法动机：\"></a>算法动机：</h5><ul>\n<li>人能够在只有很少目标类别视觉信息的情况下，在很短的时间内掌握该类别的特征，这一能力很可能来源于人脑中含有概念表征的组合结构（the compositional structure of concept representations），即人虽然没有见过该类别，但其能够迅速掌握该类别的一些高级特征（属性）。故此文尝试将图片的一些属性表征同时送入网络，增加信息量。</li>\n</ul>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"../images/6.png\"\n                      alt=\"截屏2023-07-09 15.23.23\" style=\"zoom:50%;\" \n                >\n\n<h5 id=\"算法特点：\"><a href=\"#算法特点：\" class=\"headerlink\" title=\"算法特点：\"></a>算法特点：</h5><ul>\n<li><p>为了提高图像特征提取网络和属性特征提取网络的性能，在损失函数增加了一个软约束使得二者之间尽量相似</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"../images/7.png\"\n                      alt=\"截屏2023-07-09 18.58.31\" style=\"zoom:50%;\" \n                >\n</li>\n<li><p>为了降低各个属性表征之间的相关性，避免出现冗余属性，在损失函数中增加了正交约束</p>\n</li>\n</ul>\n<h3 id=\"小样本开放集识别\"><a href=\"#小样本开放集识别\" class=\"headerlink\" title=\"小样本开放集识别\"></a>小样本开放集识别</h3><h4 id=\"Task-Adaptive-Negative-Envision-for-Few-Shot-Open-Set-Recognition\"><a href=\"#Task-Adaptive-Negative-Envision-for-Few-Shot-Open-Set-Recognition\" class=\"headerlink\" title=\"Task-Adaptive Negative Envision for Few-Shot Open-Set Recognition\"></a>Task-Adaptive Negative Envision for Few-Shot Open-Set Recognition</h4><h5 id=\"算法动机\"><a href=\"#算法动机\" class=\"headerlink\" title=\"算法动机\"></a>算法动机</h5><p>早先针对小样本开放集识别的方法，都是通过设定阈值区分正样本与负样本，该方法存在一些问题：</p>\n<ul>\n<li><p>首先，该阈值需要人工调整。</p>\n</li>\n<li><p>其次，不同的任务需要不同的阈值。</p>\n</li>\n<li><p>同一个任务，我们需要对每一个正样本都设定一个阈值，以便与负样本进行区分，设置起来非常麻烦</p>\n<p>所以，文章将阈值调整嵌入模型中，让模型自己学习一个调整函数，根据不同的任务自适应的进行调整。</p>\n</li>\n</ul>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"../images/8.png\"\n                      alt=\"截屏2023-07-09 17.50.47\" style=\"zoom: 50%;\" \n                >\n\n<h5 id=\"算法原理\"><a href=\"#算法原理\" class=\"headerlink\" title=\"算法原理\"></a>算法原理</h5><ul>\n<li>该算法设计了一个负样本原型以及阈值生成器，嵌入模型中，在模型的训练过程中进行学习，达到根据不同的任务，自适应阈值的效果。</li>\n</ul>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"../images/9.png\"\n                      alt=\"截屏2023-07-09 17.56.44\" style=\"zoom: 33%;\" \n                >\n\n<h3 id=\"DN4算法复现\"><a href=\"#DN4算法复现\" class=\"headerlink\" title=\"DN4算法复现\"></a>DN4算法复现</h3><ul>\n<li><h4 id=\"算法结构\"><a href=\"#算法结构\" class=\"headerlink\" title=\"算法结构!\"></a>算法结构!</h4></li>\n</ul>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"../images/3.png\"\n                      alt=\"截屏2023-07-09 17.56.44\" style=\"zoom: 33%;\" \n                >\n\n<p>DN4是一种基于度量的小样本识别算法</p>\n<p>1.首先是一个没有检测头，只有骨干网络的CNN，其作用就是提取图片中的特征，并以特征向量的形式表示</p>\n<p>（hw，d），其中hw为特征图的大小，d为特征图的数量（通道数，深度）</p>\n<p>2.接着是image-to-Class模块，该模块的作用就是将query image与support set中的images进行相似度度量，并确定其属于哪个类。具体来说，对于support set中的每一个类，我们对query image的每一个局部特征向量，都在support set中该类所有images的所有局部特征向量组成的集合中，使用k近邻算法找出余弦距离最近的k个特征向量，然后求和得到image-to-class（query image to support set中的一个类）的余弦距离总和，那么显然，该图片应该属于该距离最近的类，公式如下：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"../images/10.png\"\n                      alt=\"截屏2023-07-08 22.18.17\" style=\"zoom:50%;\" \n                >\n\n<ul>\n<li><h4 id=\"代码实现（基于LibFewShot）\"><a href=\"#代码实现（基于LibFewShot）\" class=\"headerlink\" title=\"代码实现（基于LibFewShot）\"></a>代码实现（基于LibFewShot）</h4><div class=\"highlight-container\" data-rel=\"Python\"><figure class=\"iseeu highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># image-to-Class模块</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">        self,</span></span><br><span class=\"line\"><span class=\"params\">        query_feat,</span></span><br><span class=\"line\"><span class=\"params\">        support_feat,</span></span><br><span class=\"line\"><span class=\"params\">        way_num,</span></span><br><span class=\"line\"><span class=\"params\">        shot_num,</span></span><br><span class=\"line\"><span class=\"params\">        query_num,</span></span><br><span class=\"line\"><span class=\"params\">    </span>):</span><br><span class=\"line\">        t, wq, c, h, w = query_feat.size()</span><br><span class=\"line\">        _, ws, _, _, _ = support_feat.size()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># t, wq, c, hw -&gt; t, wq, hw, c -&gt; t, wq, 1, hw, c</span></span><br><span class=\"line\">        query_feat = query_feat.view(t, way_num * query_num, c, h * w).permute(</span><br><span class=\"line\">            <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">        query_feat = F.normalize(query_feat, p=<span class=\"number\">2</span>, dim=-<span class=\"number\">1</span>).unsqueeze(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># t, ws, c, h, w -&gt; t, w, s, c, hw -&gt; t, 1, w, c, shw</span></span><br><span class=\"line\">        support_feat = (</span><br><span class=\"line\">            support_feat.view(t, way_num, shot_num, c, h * w)</span><br><span class=\"line\">            .permute(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">            .contiguous()</span><br><span class=\"line\">            .view(t, way_num, c, shot_num * h * w)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        support_feat = F.normalize(support_feat, p=<span class=\"number\">2</span>, dim=<span class=\"number\">2</span>).unsqueeze(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># t, wq, w, hw, shw -&gt; t, wq, w, hw, n_k -&gt; t, wq, w</span></span><br><span class=\"line\">        <span class=\"comment\"># 张量点乘，从算法上可以理解为只有4，5两个维度在做点乘，从功能上，结合上面的归一化操作</span></span><br><span class=\"line\">        <span class=\"comment\"># 这里实际上就是在计算query image和support image中局部特征向量之间的余弦相似度</span></span><br><span class=\"line\">        relation = torch.matmul(query_feat, support_feat)</span><br><span class=\"line\">        <span class=\"comment\"># k近邻算法，只留下距离相近的k个值</span></span><br><span class=\"line\">        topk_value, _ = torch.topk(relation, self.n_k, dim=-<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 求余弦距离总和，代表image-to-class，即query image和supprot</span></span><br><span class=\"line\">        score = torch.<span class=\"built_in\">sum</span>(topk_value, dim=[<span class=\"number\">3</span>, <span class=\"number\">4</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> score</span><br></pre></td></tr></table></figure></div>\n\n<div class=\"highlight-container\" data-rel=\"Python\"><figure class=\"iseeu highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">support_feat = (</span><br><span class=\"line\">            support_feat.view(t, way_num, shot_num, c, h * w)</span><br><span class=\"line\">            .permute(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">            .contiguous()</span><br><span class=\"line\">            .view(t, way_num, shot_num * h * w, c)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        support_feat = F.normalize(support_feat, p=<span class=\"number\">2</span>, dim=<span class=\"number\">2</span>).unsqueeze(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># t, wq, w, hw, shw -&gt; t, wq, w, hw, n_k -&gt; t, wq, w</span></span><br><span class=\"line\">        <span class=\"comment\"># relation = torch.matmul(query_feat, support_feat)</span></span><br><span class=\"line\">        <span class=\"comment\"># 改为欧式距离度量相似度，相应的support_feat张量的形状需改变一下</span></span><br><span class=\"line\">        relation = torch.cdist(query_feat, support_feat, p=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></div>\n\n\n</li>\n<li><h4 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h4><table>\n<thead>\n<tr>\n<th>Shot</th>\n<th>dn4-n</th>\n<th>相似度衡量</th>\n<th>特征图尺寸</th>\n<th>测试集准确率</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>3</td>\n<td>余弦</td>\n<td>$64<em>5</em>5$</td>\n<td>30.345%</td>\n</tr>\n<tr>\n<td>5</td>\n<td>3</td>\n<td>余弦</td>\n<td>$64<em>5</em>5$</td>\n<td>56.606%</td>\n</tr>\n<tr>\n<td>5</td>\n<td>5</td>\n<td>余弦</td>\n<td>$64<em>5</em>5$</td>\n<td>55.148%</td>\n</tr>\n<tr>\n<td>5</td>\n<td>5</td>\n<td>余弦</td>\n<td>$32<em>5</em>5$</td>\n<td>51.400%</td>\n</tr>\n<tr>\n<td>5</td>\n<td>5</td>\n<td>欧式</td>\n<td>$32<em>5</em>5$</td>\n<td>22.380%</td>\n</tr>\n</tbody></table>\n<p>时间与算力有限，没有做大规模的测试，只做了以上5组</p>\n<p>可以发现，shot增加可以使准确率大幅上升，将相似度衡量方法换为欧式距离后准确率大幅下降</p>\n<p>而dn4-n和特征图尺寸(主要是通道数&#x2F;深度d)的变化对测试集影响不大</p>\n</li>\n</ul>\n",
            "tags": [
                "科研"
            ]
        },
        {
            "id": "https://renshengji.github.io/2023/07/02/%E7%AC%AC%E4%B8%80%E5%91%A8%E5%91%A8%E6%8A%A5%E7%9A%84%E5%89%AF%E6%9C%AC/",
            "url": "https://renshengji.github.io/2023/07/02/%E7%AC%AC%E4%B8%80%E5%91%A8%E5%91%A8%E6%8A%A5%E7%9A%84%E5%89%AF%E6%9C%AC/",
            "title": "人生几何的科研之旅——第一周周报",
            "date_published": "2023-07-02T15:48:03.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>[TOC]</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本周主要通过阅读老师推荐的文献，以及一些视频和博客，对小样本图像识别领域经典方法，开放世界小样本学习有了一定的理解。（由于本周有一些课程的大作业，所以时间比较紧张，没来得及看代码）</p>\n<h2 id=\"小样本图像识别领域经典方法\"><a href=\"#小样本图像识别领域经典方法\" class=\"headerlink\" title=\"小样本图像识别领域经典方法\"></a>小样本图像识别领域经典方法</h2><p>小样本图像识别是指在数据集较小的情况下，通过一些方法来提高模型的泛化能力，进行图像识别任务</p>\n<h3 id=\"1-数据增强\"><a href=\"#1-数据增强\" class=\"headerlink\" title=\"1.数据增强\"></a>1.数据增强</h3><p>数据增强是指通过对训练数据进行一定的变换，生成新的数据来扩充训练集，从而增加数据的多样性和数量。这种方法可以帮助模型更好地学习图像的不变性和鲁棒性，提高模型的泛化能力。常见的数据增强方法包括旋转、平移、缩放、翻转、添加噪声等。</p>\n<h3 id=\"2-元学习\"><a href=\"#2-元学习\" class=\"headerlink\" title=\"2.元学习\"></a>2.元学习</h3><p>元学习是学习如何学习的一种方法，它可以在多个任务之间学习，并具有快速适应新任务的能力。在小样本图像识别中，元学习可以帮助模型在仅有几个样本的情况下快速适应新的分类任务。</p>\n<h4 id=\"基于优化的MAML方法\"><a href=\"#基于优化的MAML方法\" class=\"headerlink\" title=\"基于优化的MAML方法\"></a>基于优化的MAML方法</h4><p>MAML算法的核心思想是在多个任务之间学习共享知识，通过不断地更新模型参数来适应新的任务。</p>\n<h4 id=\"基于度量的Prototypical-Network方法\"><a href=\"#基于度量的Prototypical-Network方法\" class=\"headerlink\" title=\"基于度量的Prototypical Network方法\"></a>基于度量的Prototypical Network方法</h4><p>ProtoNet方法通过计算每个类别的原型向量来进行分类。原型向量是一个类别的所有样本向量的平均值，表示该类别的特征中心。在训练阶段，ProtoNet方法通过计算每个类别的原型向量来学习分类器。在测试阶段，ProtoNet方法通过计算测试样本与每个类别的原型向量的距离来进行分类。</p>\n<h4 id=\"基于度量的DN4方法\"><a href=\"#基于度量的DN4方法\" class=\"headerlink\" title=\"基于度量的DN4方法\"></a>基于度量的DN4方法</h4><p>DN4方法的核心思想是提取图像的局部特征，并使用朴素贝叶斯最近邻算法进行相似性度量。</p>\n<h3 id=\"3-预训练-微调\"><a href=\"#3-预训练-微调\" class=\"headerlink\" title=\"3.预训练+微调\"></a>3.预训练+微调</h3><p>预训练+微调是指使用大规模图像数据集预训练一个深度学习模型，然后在小样本图像识别任务中微调模型。预训练可以帮助模型学习更好的图像特征，提高模型的泛化能力。在微调过程中，模型会根据小样本图像数据集进行微调，以适应新的分类任务。</p>\n<h2 id=\"开放世界小样本学习\"><a href=\"#开放世界小样本学习\" class=\"headerlink\" title=\"开放世界小样本学习\"></a>开放世界小样本学习</h2><p>开放世界小样本学习指的是在小样本学习任务中，考虑到可能存在未知类别的情况，即在测试阶段可能会出现训练集中没有出现过的类别。传统的小样本学习方法只能处理已知类别，无法应对未知类别的情况。</p>\n<h3 id=\"1-跨域小样本学习\"><a href=\"#1-跨域小样本学习\" class=\"headerlink\" title=\"1.跨域小样本学习\"></a>1.跨域小样本学习</h3><p>跨域小样本学习（Cross-domain Few-shot Learning）是指在小样本学习任务中，模型需要在训练和测试时处理不同来源的数据集，即跨越不同的数据域。在实际应用中，跨域小样本学习具有广泛的应用场景，如在医学图像识别中利用来自不同医院的数据集进行模型训练和测试。</p>\n<h3 id=\"2-小样本开放集识别\"><a href=\"#2-小样本开放集识别\" class=\"headerlink\" title=\"2.小样本开放集识别\"></a>2.小样本开放集识别</h3><p>小样本开放集识别（Few-Shot Open-Set Recognition）是指在小样本学习任务中，模型需要处理未知类别的情况，并且测试集中可能包含已知类别和未知类别两种情况。相比于传统的小样本识别任务，开放集识别任务需要模型具备更强的泛化能力和鲁棒性，因此具有更高的难度和挑战性。</p>\n<h3 id=\"3-通用小样本学习\"><a href=\"#3-通用小样本学习\" class=\"headerlink\" title=\"3.通用小样本学习\"></a>3.通用小样本学习</h3><p>通用小样本学习（Generalized Few-shot Learning）是指在小样本学习任务中，模型需要具备在不同任务之间进行迁移学习的能力。相比于传统的小样本学习任务，通用小样本学习任务考虑到了不同任务之间的相似性和差异性。</p>\n",
            "tags": [
                "科研"
            ]
        }
    ]
}